export const withLazyFetching = ({ nodeishFs, verbose = false, description, intercept, }) => {
    return new Proxy(nodeishFs, {
        get(getTarget, prop, receiver) {
            if (getTarget[prop]) {
                return new Proxy(getTarget[prop], {
                    apply(callTarget, thisArg, argumentsList) {
                        if (verbose) {
                            console.warn(`${description} fs:`, prop, argumentsList);
                        }
                        const execute = () => Reflect.apply(callTarget, thisArg, argumentsList);
                        return intercept
                            ? intercept({ prop, argumentsList, execute })
                            : execute();
                    },
                });
            }
            return Reflect.get(getTarget, prop, receiver);
        },
    });
};
/**
 * Transforms a remote URL to a standard format.
 */
export function transformRemote(remote) {
    // Match HTTPS pattern or SSH pattern
    const regex = /(?:https:\/\/|@|git:\/\/)([^/]+)\/(.+?)(?:\.git)?$/;
    const matches = remote.match(regex);
    if (matches && matches[1] && matches[2]) {
        let host = matches[1].replace(/:/g, "/"); // Replace colons with slashes in the host
        const repo = matches[2];
        // Remove ghp_ key if present in the host
        host = host.replace(/ghp_[\w]+@/, "");
        return `${host}/${repo}.git`;
    }
    return "unknown"; // Return unchanged if no match
}
export function parseLixUri(uriText) {
    let url;
    try {
        url = new URL(uriText);
    }
    catch (error) {
        // console.error(error, uriText) use only for debugging could leak secrets into logs
        return {
            error,
            username: "",
            password: "",
            protocol: "",
            lixHost: "",
            namespace: "",
            repoHost: "",
            owner: "",
            repoName: "",
        };
    }
    const { protocol, host, pathname, username, password } = url;
    const pathParts = pathname.split("/");
    let lixHost = "";
    let namespace = "";
    let repoHost = "";
    let owner = "";
    let repoName = "";
    if (host === "github.com") {
        repoHost = host;
        owner = pathParts[1] || "";
        repoName = pathParts[2] || "";
        if (!repoHost || !owner || !repoName) {
            return {
                error: new Error(`Invalid url format for '${uriText}' for direct cloning repository from github, please use the format of https://github.com/opral/monorepo.`),
                username,
                password,
                protocol,
                lixHost,
                namespace,
                repoHost,
                owner,
                repoName,
            };
        }
    }
    else {
        lixHost = host;
        namespace = pathParts[1] || "";
        repoHost = pathParts[2] || "";
        owner = pathParts[3] || "";
        repoName = pathParts[4] || "";
        if (!namespace || !host || !owner || !repoName) {
            return {
                error: new Error(`Invalid url format for '${uriText}' for cloning repository, please use the format of https://lix.inlang.com/git/github.com/opral/monorepo.`),
                username,
                password,
                protocol,
                lixHost,
                namespace,
                repoHost,
                owner,
                repoName,
            };
        }
    }
    return {
        username,
        password,
        protocol,
        lixHost,
        namespace,
        repoHost,
        owner,
        repoName,
    };
}
